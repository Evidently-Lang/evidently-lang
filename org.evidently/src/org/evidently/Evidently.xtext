grammar org.evidently.Evidently with org.eclipse.xtext.xbase.Xtype
// with org.eclipse.xtext.common.Terminals
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes


/**
 * Removing left recursion (general rule)
 * A -> A a | b
 * by:
 * A -> b A'
 * A'-> aA' | (empty)
 */


generate evidently "http://www.evidently.org/Evidently"

//DataType:
//  'datatype' name=ID 
//  'mapped-to' javaType=ProgType;
//


PolicyFile:
	(elements+=FileElem)*
	;

ProgId: ID;

EvidentlyId: 
	ID ('.' ID)*
;

ProgType:
	 {ProgType} "byte" ProgTypePrime
	| {ProgType} "short"  ProgTypePrime 
	| {ProgType} "int"  ProgTypePrime
	| {ProgType} "long"  ProgTypePrime
 	| {ProgType} "float"  ProgTypePrime
 	| {ProgType} "double"  ProgTypePrime
 	| {ProgType} "char"  ProgTypePrime
 	| {ProgType} "boolean" ProgTypePrime
 	| {ProgType} "void"
	| javaType=[jvmTypes::JvmType|QualifiedName] ProgTypePrime // takes the place of ProgId rules.
;

ProgTypePrime:
	("[" "]" ProgTypePrime)?
;

		
FileElem:
	ImportLevels
	| Policy 
	| Model
	| Levels
;
	
ImportLevels:
	'using' 'levels' name=ID
;	

Policy:
	'policy' name=ID '{' 
		(elements+=PoBElem)*	
	'}'
	| 
	'policy' name=ID params=GParams '{' 
		(elements+=PoBElem)*	
	'}'
	
;	

GParams:
	'<' params+=ID (',' params+=ID)*  '>'
;

PoBElem:
	Use
	| Release
	| EnforceDirective 
;

Use:
	UsePolicy
	| UseElem
;	


UsePolicy:
	'use' 'policy' name=ID ';'
	| 'use' 'policy' name=ID 'as' alias=ID ';'
	| 'use' 'policy' name=ID args=GArgs ';'
	| 'use' 'policy' name=ID args=GArgs 'as' alias=ID ';'
;	

GArgs:
	"<" args+=GenericArg (',' args+=GenericArg)* ">"
;

GenericArg:
	name=ID
	| '*' name="*"
	| "{" names+=ID (',' names+=ID)*
;


UseElem:
	'use' kind=UseKind name=ID ';'
	| 'use' kind=UseKind name=ID 'as' alias=ID ';'
;	

UseKind:  
	'model' 
;



Release:
	'release' '(' what=EvidentlyId ',' flow=LevelFlow  ')'  '=' '{' (releases+=RTime)* '}'
	| 'release' '(' what=EvidentlyId ',' flow=LevelFlow  ')' ';' 	
	| 'release' '(' '*' what='*' ',' flow=LevelFlow  ')' ';' 
	 
;

LevelFlow:
	from=GenericArg "->" to=GenericArg
;	

RTime:
	'when' '{' condition=Exp '}'
	| 'unless' '{' notCondition=Exp'}'
	
;

//TODO: need to do Exp, EvidentlyId, ProgId, and Exps
//Exp: Addition; // map to toplevel rule
//
//// left recursion removed from expression grammar
//Addition returns Expression:
//  Multiplication ({Addition.left=current} '+' right=Multiplication)*;
//
//Multiplication returns Expression:
//  Primary ({Multiplication.left=current} '*' right=Primary)*;
//
//Primary returns Expression:
//  ProgType 
//  | '(' Addition ')';

//NumberLiteral:
//  value=INT;
//
//BooleanLiteral:
//  "true" value="true"
//  | "false" value="false"
//;
//
//StringLiteral:
//  value=STRING;

Exp: 
	'a' name='a'
;

	
EnforceDirective:
	'enforce' mode=EnforceMode policy=ID	
;	

EnforceMode:
	'static' | 'runtime'
;



Model:
	'model' name=ID '{' (elements+=MBElem)* '}'
;	

MBElem: 
	Use 
	| Flowpoints
	| Property
;


Flowpoints:
	'flowpoints' name=ID ':' type=ProgType '=' '{' body=EvBody '}'
	| 'flowpoints' name=ID '{' body=EvBody '}'
;

// this looks wrong but it's right. 
EvBody : EvExp;
EvExp : EvAnd;
EvAnd returns EvExpression:
  EvOr ({EvAnd.left=current} '&&' right=EvOr)*;

EvOr returns EvExpression:
  EvExpBase ({EvOr.left=current} '||' right=EvExpBase)*;

EvExpBase returns EvExpression:
  '(' EvAnd ')'
  | predicate=EvPredExtended '(' description=MethDescs ')'
  | predicate=EvScopePred '(' name=EvidentlyId ')'
  | '!' EvAnd
  ;
  




//EvExp :
//	'(' EvExp ')' EvExpPrime
//	| predicate=EvPredExtended '(' description=MethDescs ')' EvExpPrime 
//	| predicate=EvScopePred '(' name=EvidentlyId ')' EvExpPrime 
//	| '!' EvExp EvExpPrime 
//;
//
//EvExpPrime:
//	('&&' EvExp EvExpPrime)*
//;
//
//EvExpPrimePrime:
//	('||' EvExp EvExpPrimePrime)*		
//;
// EvExp (&& EvExp)
/* 
Removing left recursion (general rule)
 * A -> A a | b
 * by:
 * A -> b A'
 * A'-> aA' | (empty)
 */
EvPredExtended : 'execution' | 'resultof' | 'this'  | 'cflow';
EvScopePred    : 'within'    | 'typeof'   | 'named' | 'field';

MethDescs:
	elements+=MethDesc (',' elements+=MethDesc)* 
;

MethDesc:
	name=IdOrStar
	| name=IdOrStar '(' signature=(MethFormalDescs)? ')'
	| type=TypeOrStar name=IdOrStar'(' signature=(MethFormalDescs)? ')'
	;

IdOrStar: 
	EvidentlyId 
	| '*'
;
TypeOrStar: 
	{TypeOrStar} '*' 
	| ProgType
;

MethFormalDescs:
	desc='...'
	| descs+=TypeOrStar (',' descs+=TypeOrStar)*
;

Property:
	'property' name=ID (':' type=ProgType)? (spec=EqSpec)? '{' expression=PropBody '}'
	| 'property' name=ID formals=PFormals (':' type=ProgType)? spec=(EqSpec)? '{' expression=PropBody '}'
			
;

EqSpec :
	spec+=(Specification)+
;

Specification:
	requires=Requires assignable=Assignable ensures=Ensures
	| assignable=Assignable ensures=Ensures
	| requires=Requires ensures=Ensures 
	| ensures=Ensures
;


Requires: 'requires' expression=Exp';';
Assignable: 'assignable' expression=Exp ';';
Ensures: 'ensures' expression=Exp ';';

PropBody : Exp;

PFormals:
	{PFormals} '('  (args=Formals)? ')' 
;

Formals:
	elements+=Formal (',' elements+=Formal)*
;

Formal:
	//{Formal} name=ID
	{Formal} name=ID ':' type=ProgType
;


Levels:
	'levels' name=ID '{' (elements+=LevElem)* '}'
;	

LevElem:
	kind=LevelKind '{' elements=(LevelBodyElems)? '}'
;

LevelKind:
	'sink' | 'source' | 'both'
;

LevelBodyElems:
	elements+=LevelBodyElem (',' elements+=LevelBodyElem)*
;
LevelBodyElem:
	name=ID
;