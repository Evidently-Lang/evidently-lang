/*
 * generated by Xtext 2.12.0
 */
package org.evidently.jvmmodel

import com.google.inject.Inject
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import org.evidently.evidently.PolicyFile
import org.evidently.evidently.Policy
import org.evidently.evidently.PoBElem
import org.evidently.evidently.Use
import org.evidently.evidently.Release
import org.evidently.evidently.Model
import org.evidently.evidently.FileElem
import org.evidently.evidently.UseElem
import org.evidently.evidently.MBElem
import org.evidently.evidently.Flowpoints
import org.eclipse.xtext.common.types.JvmTypeReference
import org.evidently.evidently.ProgType
import org.evidently.evidently.PropertyOrFlowpoint
import org.eclipse.xtext.common.types.JvmField
import org.eclipse.xtext.common.types.JvmVisibility
import org.eclipse.xtext.common.types.JvmAnnotationType
import org.evidently.annotations.ReleasePolicyFor
import java.util.ArrayList
import java.util.List
import org.evidently.evidently.RTime
import org.eclipse.xtext.xbase.XExpression
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.evidently.agent.Flowpoint
import org.evidently.agent.MethodCall
import org.evidently.agent.ASTType
import org.evidently.evidently.EvExp
import org.evidently.evidently.Levels
import org.evidently.evidently.LevElem
import org.evidently.evidently.LevelBodyElem
import org.eclipse.xtext.common.types.JvmType
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.common.types.JvmAnnotationReference
import org.eclipse.xtext.common.types.JvmStringAnnotationValue
import org.eclipse.xtext.common.types.JvmOperation
import org.eclipse.xtext.common.types.JvmBooleanAnnotationValue
import org.eclipse.xtext.util.internal.Nullable
import org.eclipse.xtext.common.types.TypesFactory
import org.eclipse.xtext.common.types.util.TypeReferences
import org.evidently.evidently.Property
import org.evidently.evidently.Requires
import org.evidently.evidently.Ensures
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.common.util.ECollections

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class EvidentlyJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder

	/**
	 * The dispatch method {@code infer} is called for each instance of the
	 * given element's type that is contained in a resource.
	 * 
	 * @param element
	 *            the model to create one or more
	 *            {@link org.eclipse.xtext.common.types.JvmDeclaredType declared
	 *            types} from.
	 * @param acceptor
	 *            each created
	 *            {@link org.eclipse.xtext.common.types.JvmDeclaredType type}
	 *            without a container should be passed to the acceptor in order
	 *            get attached to the current resource. The acceptor's
	 *            {@link IJvmDeclaredTypeAcceptor#accept(org.eclipse.xtext.common.types.JvmDeclaredType)
	 *            accept(..)} method takes the constructed empty type for the
	 *            pre-indexing phase. This one is further initialized in the
	 *            indexing phase using the lambda you pass as the last argument.
	 * @param isPreIndexingPhase
	 *            whether the method is called in a pre-indexing phase, i.e.
	 *            when the global index is not yet fully updated. You must not
	 *            rely on linking using the index if isPreIndexingPhase is
	 *            <code>true</code>.
	 */
//	def dispatch void infer(PolicyFile element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
//		
//		
//		for(e : element.elements){
//			if(e instanceof Policy){
//				
//			}
//		}
//		
//		// Here you explain how your model is mapped to Java elements, by writing the actual translation code.
//		
//		// An implementation for the initial hello world example could look like this:
// 		acceptor.accept(element.toClass("org.evidently.policy.MyGreetings")) [
// 			for (greeting : element.greetings) {
// 				members += greeting.toMethod("hello" + greeting.name, typeRef(String)) [
// 					body = '''
//						return "Hello «greeting.name»";
//					'''
//				]
//			}
//		]
//	}
	def String fromJavaName(String name) {
		if (name.equals("$STAR")) {
			return "*"
		}
		return name.replaceAll("___", ".")
	}

	def String toJavaName(PropertyOrFlowpoint name) {
		if (name instanceof Flowpoints) {
			return toJavaName(name as Flowpoints)
		} else if (name instanceof org.evidently.evidently.Property) {
			return toJavaName(name as org.evidently.evidently.Property)
		}
	}

	def String toJavaName(org.evidently.evidently.Property name) {
		return toJavaName((name.eContainer as Model).name + "." + name.name)
	}

	def String toJavaName(Flowpoints name) {
		return toJavaName((name.eContainer as Model).name + "." + name.name)
	}

	def String toJavaName(String name) {

		if (name.equals("*")) {
			return "$STAR"
		}

		return name.replaceAll("\\.", "___")
	}

	var currentId = 0

	def int newId() {
		currentId++
		return currentId
	}

//	def dispatch void infer(FileElem element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
//		System.out.println("FILE - ELEM")
//
//	}
	int flowpointIndex;
	int propertyIndex;

	def getNextFlowpointName() {
		val name = String.format("Flowpoint$%d", flowpointIndex)
		flowpointIndex = ( flowpointIndex + 1 )
		return name
	}

	def getNextPropertyName() {
		val name = String.format("Property$%d", propertyIndex)
		propertyIndex = ( propertyIndex + 1 )
		return name
	}

	def analyzeFlowpointAndPropertyDeps() {
	}

	def evExpToJavaExpression(EvExp expression) {

		var node = NodeModelUtils.getNode(expression)

		var base = NodeModelUtils.getTokenText(node)

		base = base.replaceAll("(within)\\((.*?)\\)", "$1(\"$2\")");
		base = base.replaceAll("(execution)\\((.*?)\\)", "$1(\"$2\")");
		base = base.replaceAll("(resultof)\\((.*?)\\)", "$1(\"$2\")");
		base = base.replaceAll("(this)\\((.*?)\\)", "pThis(\"$2\")");
		base = base.replaceAll("(cflow)\\((.*?)\\)", "$1(\"$2\")");
		base = base.replaceAll("(named)\\((.*?)\\)", "$1(\"$2\")");
		base = base.replaceAll("(field)\\((.*?)\\)", "$1(\"$2\")");
		base = base.replaceAll("(typeof)\\((.*?)\\)", "$1(\"$2\")");

		return base

	}

	def dispatch void infer(Flowpoints flowpoint, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {

		val modelName = (flowpoint.eContainer as Model).name
		val flowpointName = flowpoint.name
		val fqFlowpointName = '''«modelName».«flowpointName»'''
		val className = getNextFlowpointName()

		// this is what we are going to transform
		val expression = flowpoint.body as EvExp

		System.out.
			println('''Generating Flowpoint: «fqFlowpointName» in class org.evidently.flowpoints.«className»...''')

		acceptor.accept(flowpoint.toClass("org.evidently.flowpoints." + className)) [

			members += flowpoint.toConstructor [
				parameters += flowpoint.toParameter("scope", typeRef(String))
				parameters += flowpoint.toParameter("type", typeRef(String))
				parameters += flowpoint.toParameter("currentClass", typeRef(String))
				parameters += flowpoint.toParameter("currentMethod", typeRef(String))
				parameters += flowpoint.toParameter("name", typeRef(String))
				parameters += flowpoint.toParameter("astType", typeRef("org.evidently.agent.ASTType"))
				parameters += flowpoint.toParameter("lastMethodCall", typeRef("org.evidently.agent.MethodCall"))

				body = '''
					super(scope, type, currentClass, currentMethod, name, astType, lastMethodCall);
				'''

			]

			members += flowpoint.toMethod('''getName''', typeRef(String)) [
				documentation = '''Flowpoint name method for«fqFlowpointName» '''
				body = '''
					return "«fqFlowpointName»";					
				'''
			]

			members += flowpoint.toMethod('''getFlowpointFor''', typeRef(String)) [
				documentation = '''Flowpoint identification method for«fqFlowpointName» '''
				body = '''
					
						System.out.println(String.format("[Evidently] [GENERATED] Calling Flowpoint (%s) with %s,%s,%s,%s,%s,%s", getName(), scope, type, currentClass, currentMethod, name, astType.toString()));
						
					
						boolean yes = «evExpToJavaExpression(expression)»;
						
						
						if(yes){
							return getName();
						}
						
						return null;
											
				'''
			]

			superTypes += typeRef("org.evidently.agent.Flowpoint")

		]

	}

	// we are going to generate properties
	// from models
	def dispatch void infer(Property prop, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {

		var Model model = prop.eContainer as Model

		// first, figure out all the things that are VISIBLE to properties 
		val flowpointNames = newHashSet()
		val propertyNames = newHashSet()

		var contextVariables = newArrayList()

		for (MBElem e : model.elements) {
			if (e instanceof UseElem) {
				// import everything 
				var UseElem theUse = e as UseElem

				var Model modelToImport = theUse.model

				// grab all the properties and flowpoints
				for (MBElem mElem : modelToImport.elements) {
					if (mElem instanceof Flowpoints) {
						var Flowpoints fp = mElem as Flowpoints
						contextVariables += fromJavaName(toJavaName(fp)) -> fp.type
						flowpointNames += fromJavaName(toJavaName(fp))
					}

					if (mElem instanceof org.evidently.evidently.Property) {
						var org.evidently.evidently.Property p = mElem as org.evidently.evidently.Property
						contextVariables += fromJavaName(toJavaName(p)) -> prop.type
						propertyNames += fromJavaName(toJavaName(p))
					}
				}
			} else if (e instanceof Property) {
				var org.evidently.evidently.Property p = e as org.evidently.evidently.Property
				contextVariables += fromJavaName(toJavaName(p)) -> prop.type
				propertyNames += fromJavaName(toJavaName(p))

			} else if (e instanceof Flowpoints) {
				var Flowpoints fp = e as Flowpoints
				contextVariables += fromJavaName(toJavaName(fp)) -> fp.type
				flowpointNames += fromJavaName(toJavaName(fp))

			}
		}
		// NOTE: type checking promises us that flowpointNames is disjoint from propertyNames
		val context = contextVariables
		val e = prop
		var propertyJavaType = "";
		if (prop.type.javaType === null) {
			propertyJavaType = prop.type.type
		} else {
			propertyJavaType = prop.type.javaType.toString()
		}

		val propertyType = propertyJavaType

		// new class for each property
		acceptor.accept(e.toClass('''org.evidently.properties.«getNextPropertyName()»''')) [
			// extends Property
			superTypes += typeRef("org.evidently.agent.Property")

			// name function
			members += e.toMethod('''getName''', typeRef(String)) [
				documentation = '''getName() method for property «fromJavaName(toJavaName(prop))»'''
				body = '''
					return " «fromJavaName(toJavaName(prop))»";					
				'''
			]
			// valuation function
			//
			val propertyDefinition = prop.expression

			// org.evidently.monitor.UnsatSpecException
			//
			val valueFunction = e.toMethod('''getValue''', typeRef("org.evidently.monitor.Pair")) [
				documentation = '''Valueation function for property «fromJavaName(toJavaName(prop))»'''
				body = '''
						//the precondition
						«generatePrecondition(context, prop)»
					
						// define the return value
						org.evidently.monitor.Pair<edu.columbia.cs.psl.phosphor.runtime.Taint,Object> p = new org.evidently.monitor.Pair<edu.columbia.cs.psl.phosphor.runtime.Taint,Object>();
						 		
						// calculate the value
						«propertyType» result = «expressionToBody(context, propertyDefinition)»;
						
						edu.columbia.cs.psl.phosphor.runtime.Taint t = edu.columbia.cs.psl.phosphor.runtime.MultiTainter.getTaint(result);
						
						p.setLeft(t);
						p.setRight(result);			
						
						// the postcondition
						«generatePostcondition(context, prop)»
						
						{
							// check the specification
							if(!__JML_pre || __JML_post){
								return p;
							}
						}
						 					
						throw new org.evidently.monitor.UnsatSpecException(String.format("__JML_pre=%s,__JML_post=%s", __JML_pre, __JML_post));
				'''
			]

			System.out.println("Creating parameters")
			for (var int i = 0; i < context.size(); i++) {
				val Pair<String, ProgType> p = context.get(i)

				val name = p.getKey()
				System.out.println("Creating parameters: " + name)
				System.out.println("Current Property Name: " + fromJavaName(toJavaName(prop)))
				// properties can't be recursive. 						
				if (name.equals(fromJavaName(toJavaName(prop))) == false) {

					System.out.println("Adding Parameter...")
					if (p.getValue().javaType === null) {
						valueFunction.parameters += e.toParameter('''arg«i»''', typeRef(p.getValue().type))
					} else {
						valueFunction.parameters += e.toParameter('''arg«i»''', typeRef(p.getValue().javaType))
					}

					if (flowpointNames.contains(name)) {
						valueFunction.parameters.last.annotations +=
							e.toAnnotationExtended("org.evidently.annotations.ReleaseParam", p.getKey(), true)
					} else {
						valueFunction.parameters.last.annotations +=
							e.toAnnotationExtended("org.evidently.annotations.ReleaseParam", p.getKey(), false)
					}

				}
			}
			members += valueFunction
		]
	}

	def dispatch void infer(Levels levels, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {

		var sinks = newHashSet()
		var sources = newHashSet()

		for (LevElem e : levels.elements) {
			for (LevelBodyElem s : e.elements.elements) {
				if (e.kind == 'sink') {
					sinks.add(s.name)
				} else if (e.kind == 'source') {
					sources.add(s.name)
				} else {
					sinks.add(s.name)
					sources.add(s.name)
				}
			}
		}

		var quoSinks = sinks.map[x|'''"«x»"''']
		var quoSources = sources.map[x|'''"«x»"''']

		val sinkList = quoSinks.join(",")
		val sourceList = quoSources.join(",")

		acceptor.accept(levels.toClass("org.evidently.labels.PolicyLabelSet")) [

			members += levels.toMethod('''sinks''', typeRef(String).addArrayTypeDimension()) [
				documentation = '''Policy defined sinks'''
				body = '''
					return new String[] { «sinkList» };
				'''
			]

			members += levels.toMethod('''sources''', typeRef(String).addArrayTypeDimension()) [
				documentation = '''Policy defined sinks'''
				body = '''
					return new String[] { «sourceList» };
				'''
			]

			superTypes += typeRef("org.evidently.labels.defaults.LabelSet")

		]

	}

	def dispatch void infer(Policy policy, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		System.out.println("FILE - POLICY isPreIndexingPhase: " + isPreIndexingPhase)

		//
		// we translate release statements
		//
		var contextVariables = newArrayList()

		//
		// first, figure out all the "use" statements for context.
		//
		for (PoBElem e : policy.elements) {
			if (e instanceof UseElem) {
				// import everything 
				var UseElem theUse = e as UseElem

				var Model modelToImport = theUse.model

				// grab all the properties and flowpoints
				for (MBElem mElem : modelToImport.elements) {

					if (mElem instanceof Flowpoints) {

						var Flowpoints fp = mElem as Flowpoints

						contextVariables += fromJavaName(toJavaName(fp)) -> fp.type
					}

					if (mElem instanceof org.evidently.evidently.Property) {

						var org.evidently.evidently.Property prop = mElem as org.evidently.evidently.Property

						contextVariables += fromJavaName(toJavaName(prop)) -> prop.type
					}
				}
			}
		}

		// var jvmTypeReference= fromSap.sapType;
		// var param = toParameter("sapOb",jvmTypeReference)
		// TODO -- only do code gen for policies that are enforced. 
		val context = contextVariables

		acceptor.accept(policy.toClass("org.evidently.policy." + policy.name)) [

			// add all the context variables
			for (PoBElem e : policy.elements) {
				if (e instanceof Release) {

					val idx = newId()

					// TODO - For now we are assuming that the "what" is always a  * or a fully qualified name -- the as syntax is not supported
					val name = toJavaName(e.what)

//				for(var int i=0; i< context.size(); i++){
//					val Pair<String,ProgType> p = context.get(i)
//					
//					if(p.getValue().javaType==null){
//						val JvmField fi = policy.toField('''release_«idx»_«name»_arg«i»''', typeRef(p.getValue().type))						
//						fi.setVisibility(JvmVisibility.PUBLIC);
//						members+=fi					
//					}else{
//						val JvmField fi =policy.toField('''release_«idx»_«name»_arg«i»''', typeRef(p.getValue().javaType))
//						fi.setVisibility(JvmVisibility.PUBLIC);
//						//fi.
//						members+=fi					
//												
//					}
//				}
//				
					val whens = newArrayList()
					val unlesses = newArrayList()
					// collect when/until expressions
					for (RTime r : e.releases) {

						if (r.type == 'when') {
							whens += r.condition
						}

						if (r.type == 'unless') {
							unlesses += r.notCondition
						}
					}

					// create the field args
					// we generate three methods.
					// release_id_what() <-- the base name
					// releaes_id_what_when() <-- the when conditions
					// release_id_what_unless() <-- // the unless conditions. if not specified, it is always !true 
					// this is always the same
					val mBase = e.toMethod('''release_«idx»_«name»''', typeRef(boolean)) [
						documentation = '''Exposed policy method'''
						body = '''
							return release_«idx»_«name»_when(«contextToParams(context)») && !release_«idx»_«name»_unless(«contextToParams(context)») ;
						'''
					]

					mBase.annotations +=
						e.toAnnotation("org.evidently.annotations.ReleasePolicyFor", fromJavaName(name))

					val mWhen = e.toMethod('''release_«idx»_«name»_when''', typeRef(boolean)) [
						documentation = '''The "when" portion of the release statement'''

						if (whens.size() == 0) {
							body = '''
								return true;
							'''
						} else {
							body = '''
								return «expressionsToBody(context, whens)»;
							'''
						}
					]

					// TODO -- do expression substution 
					val mUnless = e.toMethod('''release_«idx»_«name»_unless''', typeRef(boolean)) [
						documentation = '''The unless portion of the release statement'''

						if (unlesses.size() == 0) {
							body = '''
								return  false;
							'''
						} else {
							body = '''
								return «expressionsToBody(context, whens)»;
							'''
						}
					]

					for (var int i = 0; i < context.size(); i++) {
						val Pair<String, ProgType> p = context.get(i)

						if (p.getValue().javaType == null) {
							mBase.parameters += e.toParameter('''arg«i»''', typeRef(p.getValue().type))
							mWhen.parameters += e.toParameter('''arg«i»''', typeRef(p.getValue().type))
							mUnless.parameters += e.toParameter('''arg«i»''', typeRef(p.getValue().type));
						} else {
							mBase.parameters += e.toParameter('''arg«i»''', typeRef(p.getValue().javaType))
							mWhen.parameters += e.toParameter('''arg«i»''', typeRef(p.getValue().javaType))
							mUnless.parameters += e.toParameter('''arg«i»''', typeRef(p.getValue().javaType));
						}

						mBase.parameters.last.annotations +=
							e.toAnnotationExtended("org.evidently.annotations.ReleaseParam", p.getKey(), true)
						mWhen.parameters.last.annotations +=
							e.toAnnotationExtended("org.evidently.annotations.ReleaseParam", p.getKey(), true)
						mUnless.parameters.last.annotations +=
							e.toAnnotationExtended("org.evidently.annotations.ReleaseParam", p.getKey(), true)
					}

					members += mBase
					members += mWhen
					members += mUnless

				}

			}
		]

	}

	def expressionToBody(ArrayList<Pair<String, ProgType>> pairs, XExpression expression) {

		val XExpression e = expression

		var node = NodeModelUtils.getNode(e)

		var txt = NodeModelUtils.getTokenText(node)

		// this is bad but quick
		for (var i = 0; i < pairs.size(); i++) {
			var Pair<String, ProgType> p = pairs.get(i)
			txt = txt.replaceAll(p.getKey(), "arg" + i)
		}

		return txt;
	}

	// NOTE -- multiple WHEN clauses create a disjunction 
	// ANY of them can be satisfied. 
	def expressionsToBody(ArrayList<Pair<String, ProgType>> pairs, ArrayList<XExpression> expressions) {

		var List<String> buffer = new ArrayList<String>();

		for (XExpression  e : expressions) {
			buffer.add(expressionToBody(pairs, e))
		}

		return String.join("||", buffer);
	}

	def contextToParams(ArrayList<Pair<String, ProgType>> pairs) {

		var List<String> args = new ArrayList<String>();

		for (var int i = 0; i < pairs.size(); i++) {
			args.add('''arg«i»''')
		}
		return String.join(", ", args)
	}

	def generatePostcondition(ArrayList<Pair<String, ProgType>> pairs, Property property) {

		if (property.spec === null || property.spec.ensures === null || property.spec.ensures.size() === 0) {
			return '''
				boolean __JML_post = false;
				{
					
					// postcondition
					__JML_post = true;
					
				}
			'''
		}

		// the postcondition also can work with the meta variable \result (bound to the 
		// local variable "result"
		var List<String> buffer = new ArrayList<String>();

		for (Ensures e : property.spec.ensures) {
			buffer.add(expressionToBody(pairs, e.expression))
		}

		val String pc = String.join("&&", buffer).replaceAll("\\\\result", "result");

		return '''
			boolean __JML_post = false;
			{
				
				// postcondition
				__JML_post = «pc»;
				
			}				
		'''
	}

	def generatePrecondition(ArrayList<Pair<String, ProgType>> pairs, Property property) {

		if (property.spec === null || property.spec.requires === null || property.spec.requires.size() == 0) {
			return '''
				boolean __JML_pre = false;
				{
					
					// precondition
					__JML_pre = true;
					
				}
			'''
		}
		var List<String> buffer = new ArrayList<String>();

		for (Requires  r : property.spec.requires) {
			buffer.add(expressionToBody(pairs, r.expression))
		}

		val String pc = String.join("&&", buffer);

		return '''
			boolean __JML_pre = false;
			{
				
				// precondition
				__JML_pre = «pc»;
				
			}
			
			
		'''

	}

	@Inject
	private TypeReferences references;

	@Inject
	private TypesFactory typesFactory;

	def JvmAnnotationReference toAnnotationExtended(EObject sourceElement, @Nullable String annotationTypeName,
		String name, boolean isFlowpoint) {

		var JvmAnnotationReference result = typesFactory.createJvmAnnotationReference();
		var JvmType jvmType = references.findDeclaredType(annotationTypeName, sourceElement);
		if (jvmType == null) {
			throw new IllegalArgumentException("The type " + annotationTypeName + " is not on the classpath.");
		}
		if (!(jvmType instanceof JvmAnnotationType)) {
			throw new IllegalArgumentException("The given class " + annotationTypeName + " is not an annotation type.");
		}

		var JvmAnnotationType annotationType = jvmType as JvmAnnotationType;
		result.setAnnotation(annotationType);

		{
			var JvmStringAnnotationValue annotationValue = typesFactory.createJvmStringAnnotationValue();
			annotationValue.getValues().add(name);
			var JvmOperation operation = getJvmOperation(annotationType, "value");
			if (operation !== null) {
				annotationValue.setOperation(operation);
			}
			result.explicitValues.add(annotationValue)
		}

		{
			var JvmBooleanAnnotationValue annotationValue = typesFactory.createJvmBooleanAnnotationValue();

			annotationValue.getValues().add(isFlowpoint);

			var JvmOperation operation = getJvmOperation(annotationType, "isFlowpoint");
			if (operation !== null) {
				annotationValue.setOperation(operation);
			}
			result.explicitValues.add(annotationValue)
		}

		return result;
	}

	def JvmOperation getJvmOperation(JvmAnnotationType type, String name) {
		for (JvmOperation op : type.getDeclaredOperations()) {
			if (op.getSimpleName().equals(name)) {
				return op;
			}
		}
		return null;
	}

}
